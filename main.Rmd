---
title: "sta302"
author: "Pierre Catoire"
date: "15/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(papeR)
library(mice)
library(visdat)
library(VIM)
library(epiDisplay)
library(lattice)
library(nlme)

set.seed(1)
```

## Enoncé

Sujet 5: Association entre score de santé cardio-vasculaire optimale et évolution de la symptomatologie dépressive chez les personnes âgées.

Un score de Santé Cardio-Vasculaire optimale a été très récemment associé à un risque réduit de démence et un déclin cognitif moindre chez les personnes âgées [1]. L’objectif de ce projet est d’évaluer si ce score de santé Cardio-Vasculaire optimale est aussi associé à l’évolution de la symptomatologie dépressive chez les personnes âgées. Dans un premier temps, il s’agira d’évaluer l’impact de la santé cardio-vasculaire optimale
sur la trajectoire de la symptomatologie dépressive telle que mesurée par la CES-D (la CES-D sera considérée comme une variable quantitative). Dans un deuxième temps, on pourra prendre en compte dans l’analyse l’association entre trajectoire de CES-D et la survenue de démence.

Données

Le travail sera réalisé à partir des données de l’étude des 3 Cités (3C), une cohorte populationnelle multicentrique (Bordeaux, Dijon, Montpellier) dont l’objectif était d’étudier l’impact des facteurs vasculaires sur le risque de démence dans la population âgée de 65 ans et plus. Est mis à la disposition du projet un extrait de la cohorte 3C sur les trois villes. La CES-D a été mesurée à l’inclusion puis aux suivis 1,2,4,5 et 6 ayant
eu lieu environ 2 ans, 4 ans, 7 ans, 10 ans et 12 ans après l’inclusion. L’analyse pourra être ajustée sur des facteurs de confusion potentiels.

## Chargement des données

```{r}
df = read.delim("base_3C_CVideal.txt")
names(df) = toupper(names(df))

#Vérification de l'absence de données manquantes
nrow(df[is.na.data.frame(df),])

#Vérification du type de variables
sapply(df,class)

#Correction du type de variables
df$DC6 = as.factor(df$DC6)
df$SEXE = as.factor(df$SEXE)
df$DEM0_6 = as.factor(df$DEM0_6)
df$CENTRE = as.factor(df$CENTRE)
df$ETUDE_CLAS0 = as.factor(df$ETUDE_CLAS0)
df$ANTIDEP0 = as.factor(df$ANTIDEP0)

#Vérification de la correction des types de variables
sapply(df,class)

labels(df) = c("Indicateur de décès",
               "Âge au décès ou âge aux dernières nouvelles",
               "Sexe",
               "Score de CES-D à T0",
               "Âge à l'inclusion",
               "Indicateur de démence incidente",
               "Âge de démence incidente ou temps de censure",
               "Ville de la cohorte (1:Bordeaux, 2:Dijon, 3:Montpellier)",
               "Niveau d'études en classes (1: sans études ou primaire, 2: secondaire court, 3: secondaire long, 4: enseignement supérieur",
               "Traitement antidépresseur à l'inclusion (1: oui, 0: non",
               "Âge à la visite de suivi 1",
               "Âge à la visite de suivi 2",
               "Âge à la visite de suivi 4",
               "Âge à la visite de suivi 5",
               "Âge à la visite de suivi 6",
               "Score de santé cardiovasculaire total",
               "Score de santé cardiovasculaire optimale",
               "Score CES-D à la visite de suivi 1",
               "Score CES-D à la visite de suivi 2",
               "Score CES-D à la visite de suivi 4",
               "Score CES-D à la visite de suivi 5",
               "Score CES-D à la visite de suivi 6",
               "Identifiant du sujet")
```

#### Création d'un jeu de données "éclaté"

On crée un jeu de données `{r}shatter` qui présente les données avec une ligne par visite (indexée par ID). Cette opération est longue et décrite dans la fonction `{r}shatterData()` du fichier externe `{r}externalFunctions.R`. Alternativement, on peut importer directement le fichier éclaté `{r}ShatteredDataFrame.csv`.

```{r}
shatter = read.csv("ShatteredDataFrame.csv")

#Création d'une variable temps :
```


```{r}
sapply(c("factor","numeric"),
       papeR::summarise,
       data = df)
```

#### Spaghetti plot

```{r}
#Option par lattice
color <- shatter$SEXE +1
xyplot(CESDTVISITE ~ AGEVISITE-AGE0,
       group=ID,
       data=shatter[shatter$ID%%10==0,],
       col=color,
       lwd=1,
       type = 'l',bty="n",
       xlab = "Délai depuis l'entrée",
       ylab = "Score CESD")
```

```{r}
#Option par ggplot2
p <- (ggplot(shatter)
+ geom_line(aes(x = AGEVISITE-AGE0, y = CESDTVISITE, group = ID), color="grey30", alpha = 0.8)
+ stat_smooth(aes(x = AGEVISITE-AGE0, y = CESDTVISITE), method = "loess", size = 0.75)
+ theme_bw()
+ xlab("Délai depuis l'entrée dans la cohorte (en années)")
+ ylab("Score CESDT")
)
p
```


On constate qu'il y a des données manquantes pour les variables CESDT0 à CESDT6 et AGE1 à AGE6. Ces données manquantes peuvent correspondre à des dates de dernière nouvelle ou à des absences intermittentes. On teste cette question sur AGE1 et AGE2.

```{r}
df %>% filter(is.na(AGE1) & !is.na(AGE2))
```

Il y a donc des patients qui ont été absents à la visite 1 et non à la visite 2.

### Verification de la normalité de la variable d'intérêt

```{r}
par(mfrow=c(2,3))
plot(density(df$CESDT0,na.rm=T))
plot(density(df$CESDT1,na.rm=T))
plot(density(df$CESDT2,na.rm=T))
plot(density(df$CESDT4,na.rm=T))
plot(density(df$CESDT5,na.rm=T))
plot(density(df$CESDT6,na.rm=T))
```

On propose une transformation en log :

```{r}
par(mfrow=c(2,3))
plot(density(log(df$CESDT0),na.rm=T))
plot(density(log(df$CESDT1),na.rm=T))
plot(density(log(df$CESDT2),na.rm=T))
plot(density(log(df$CESDT4),na.rm=T))
plot(density(log(df$CESDT5),na.rm=T))
plot(density(log(df$CESDT6),na.rm=T))
```

```{r}
par(mfrow=c(2,3))
plot(density(sqrt(df$CESDT0),na.rm=T))
plot(density(sqrt(df$CESDT1),na.rm=T))
plot(density(sqrt(df$CESDT2),na.rm=T))
plot(density(sqrt(df$CESDT4),na.rm=T))
plot(density(sqrt(df$CESDT5),na.rm=T))
plot(density(sqrt(df$CESDT6),na.rm=T))
```
On crée donc une variable `{r}LOGCESDT` (on ajoute 1 pour permettre que la fonction log soit définie sur toutes les valeurs) :

```{r}
shatter$LOGCESDT = log(shatter$CESDTVISITE+1)
shatter$DELAI = shatter$AGEVISITE-shatter$AGE0
```


### Présentation du modèle

On propose le modèle suivant :

$$
Y_{ij} = (\beta_{0}+\alpha_{0i}+\beta_{2}^{T}X)+(\beta_{1}+\alpha_{1i}+\beta_{3}^{T}X)t_{ij}+\epsilon
$$

avec :
$$
\alpha = \begin{pmatrix}\alpha_{0i} \\ \alpha_{1i}\end{pmatrix} \sim\mathcal{N}\big( 0,\mathcal{B}\big)
$$

et

$$
\epsilon \sim \mathcal{N}(0,\sigma_{e}^{2})
$$

#### Implémentation du modèle

```{r}
model = lme(fixed = LOGCESDT ~ DELAI,
            data = shatter,
            random = ~ DELAI | ID,
            method="ML",
            na.action=na.omit)

summary(model)
```
#Modèle avec SOM (recherche si log ou sqrt le plus pertinent : Blandine)

```{r}
#### modèle vide avec effets aléatoires sur l'intercept 

model_interc = lme(fixed = LOGCESDT ~ DELAI,
            data = shatter,
            random = ~ 1 | ID,
            method="ML",
            na.action=na.omit)

summary(model_interc)

#### modèle vide avec effets aléatoires sur intercept et pente
model_int_pente = lme(fixed = LOGCESDT ~ DELAI,
            data = shatter,
            random = ~ 1+ DELAI | ID,
            method="ML",
            na.action=na.omit)

summary(model_int_pente)

### test pente aléatoire pertinente?
devm1m2 <- 2*logLik(model_int_pente) - 2*logLik(model_interc)
pm1m2 <- 0.5*(1-pchisq(devm1m2,df=2)) + 0.5*(1-pchisq(devm1m2,df=1))
pm1m2

#oui garder les 2

### tester si intercept et pente aléatoires indépendants

m1indep <- lme(fixed = LOGCESDT ~ DELAI,
            data = shatter,
        random = list(~ 1 |ID, ~-1 + DELAI|ID) ,method="ML",na.action=na.omit )
summary(m1indep)


c(AIC(m1indep), AIC(model_int_pente))

devm1indep <- 2*logLik(model_int_pente) - 2*logLik(m1indep)
p <- 1-pchisq(devm1indep ,df=1)
p
#### pour moi la pente et l'intercept aléatoires ne sont pas indépendants mais à checker
```

#### Modèle SOM (log)
```{r}
model = lme(fixed = LOGCESDT ~ DELAI*(SOM +factor(CENTRE) +ETUDE_CLAS0+SEXE +ANTIDEP0+AGE0),
            data = shatter,
            random = ~ 1 + DELAI | ID,
            method="ML",
            na.action=na.omit)

summary(model)

AIC(model)
```
#### Modèle SOM (sqrt)

```{r}
shatter$SQRTCESDT <- sqrt(shatter$CESDTVISITE)

model_sq = lme(fixed = SQRTCESDT ~ DELAI*(SOM +CENTRE +ETUDE_CLAS0+SEXE +ANTIDEP0),
            data = shatter,
            random = ~ 1 + DELAI | ID,
            method="ML",
            na.action=na.omit)

summary(model_sq)

AIC(model_sq)
```

####### on garde le modèle avec le log car AIC inférieure

#### Adéquation du modèle
```{r}
# plot résidus standardiés 
plot (model)

{
par(mfrow=c(1,2))
hist(model$coefficients$random$ID[,1],xlab="intercept",main="predicted random intercept")
hist(model$coefficients$random$ID[,2],xlab="pente",main="predicted random slope")
}

```
